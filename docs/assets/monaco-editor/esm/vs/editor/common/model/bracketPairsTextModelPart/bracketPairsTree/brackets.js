import{escapeRegExpCharacters}from"../../../../../base/common/strings.js";import{BracketAstNode}from"./ast.js";import{toLength}from"./length.js";import{identityKeyProvider,SmallImmutableSet}from"./smallImmutableSet.js";import{Token}from"./tokenizer.js";export class BracketTokens{constructor(map){this.map=map,this.hasRegExp=!1,this._regExpGlobal=null}static createFromLanguage(configuration,denseKeyProvider){function getId(languageId,openingText){return denseKeyProvider.getKey(`${languageId}:::${openingText}`)}const brackets=configuration.characterPair.getColorizedBrackets(),closingBrackets=new Map,openingBrackets=new Set;for(const[openingText,closingText]of brackets){openingBrackets.add(openingText);let info=closingBrackets.get(closingText);const openingTextId=getId(configuration.languageId,openingText);info||(info={openingBrackets:SmallImmutableSet.getEmpty(),first:openingTextId},closingBrackets.set(closingText,info)),info.openingBrackets=info.openingBrackets.add(openingTextId,identityKeyProvider)}const map=new Map;for(const[closingText,info]of closingBrackets){const length=toLength(0,closingText.length);map.set(closingText,new Token(length,2,info.first,info.openingBrackets,BracketAstNode.create(length,configuration.languageId,info.openingBrackets)))}for(const openingText of openingBrackets){const length=toLength(0,openingText.length),openingTextId=getId(configuration.languageId,openingText),bracketIds=SmallImmutableSet.getEmpty().add(openingTextId,identityKeyProvider);map.set(openingText,new Token(length,1,openingTextId,bracketIds,BracketAstNode.create(length,configuration.languageId,bracketIds)))}return new BracketTokens(map)}getRegExpStr(){if(this.isEmpty)return null;{const keys=[...this.map.keys()];return keys.sort(),keys.reverse(),keys.map((k=>prepareBracketForRegExp(k))).join("|")}}get regExpGlobal(){if(!this.hasRegExp){const regExpStr=this.getRegExpStr();this._regExpGlobal=regExpStr?new RegExp(regExpStr,"g"):null,this.hasRegExp=!0}return this._regExpGlobal}getToken(value){return this.map.get(value)}findClosingTokenText(openingBracketIds){for(const[closingText,info]of this.map)if(info.bracketIds.intersects(openingBracketIds))return closingText}get isEmpty(){return 0===this.map.size}}function prepareBracketForRegExp(str){const escaped=escapeRegExpCharacters(str);return/^[\w ]+$/.test(str)?`\\b${escaped}\\b`:escaped}export class LanguageAgnosticBracketTokens{constructor(denseKeyProvider,getLanguageConfiguration){this.denseKeyProvider=denseKeyProvider,this.getLanguageConfiguration=getLanguageConfiguration,this.languageIdToBracketTokens=new Map}didLanguageChange(languageId){const existing=this.languageIdToBracketTokens.get(languageId);if(!existing)return!1;const newRegExpStr=BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId),this.denseKeyProvider).getRegExpStr();return existing.getRegExpStr()!==newRegExpStr}getSingleLanguageBracketTokens(languageId){let singleLanguageBracketTokens=this.languageIdToBracketTokens.get(languageId);return singleLanguageBracketTokens||(singleLanguageBracketTokens=BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId),this.denseKeyProvider),this.languageIdToBracketTokens.set(languageId,singleLanguageBracketTokens)),singleLanguageBracketTokens}}