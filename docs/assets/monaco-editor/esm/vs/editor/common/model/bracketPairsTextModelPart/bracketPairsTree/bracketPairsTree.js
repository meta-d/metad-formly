import{Emitter}from"../../../../../base/common/event.js";import{Disposable}from"../../../../../base/common/lifecycle.js";import{Range}from"../../../core/range.js";import{BracketInfo,BracketPairWithMinIndentationInfo}from"../../../textModelBracketPairs.js";import{TextEditInfo}from"./beforeEditPositionMapper.js";import{LanguageAgnosticBracketTokens}from"./brackets.js";import{lengthAdd,lengthGreaterThanEqual,lengthLessThanEqual,lengthOfString,lengthsToRange,lengthZero,positionToLength,toLength}from"./length.js";import{parseDocument}from"./parser.js";import{DenseKeyProvider}from"./smallImmutableSet.js";import{FastTokenizer,TextBufferTokenizer}from"./tokenizer.js";export class BracketPairsTree extends Disposable{constructor(textModel,getLanguageConfiguration){if(super(),this.textModel=textModel,this.getLanguageConfiguration=getLanguageConfiguration,this.didChangeEmitter=new Emitter,this.denseKeyProvider=new DenseKeyProvider,this.brackets=new LanguageAgnosticBracketTokens(this.denseKeyProvider,this.getLanguageConfiguration),this.onDidChange=this.didChangeEmitter.event,0===textModel.backgroundTokenizationState){const brackets=this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId()),tokenizer=new FastTokenizer(this.textModel.getValue(),brackets);this.initialAstWithoutTokens=parseDocument(tokenizer,[],void 0,!0),this.astWithTokens=this.initialAstWithoutTokens}else 2===textModel.backgroundTokenizationState?(this.initialAstWithoutTokens=void 0,this.astWithTokens=this.parseDocumentFromTextBuffer([],void 0,!1)):1===textModel.backgroundTokenizationState&&(this.initialAstWithoutTokens=this.parseDocumentFromTextBuffer([],void 0,!0),this.astWithTokens=this.initialAstWithoutTokens)}didLanguageChange(languageId){return this.brackets.didLanguageChange(languageId)}handleDidChangeBackgroundTokenizationState(){if(2===this.textModel.backgroundTokenizationState){const wasUndefined=void 0===this.initialAstWithoutTokens;this.initialAstWithoutTokens=void 0,wasUndefined||this.didChangeEmitter.fire()}}handleDidChangeTokens({ranges}){const edits=ranges.map((r=>new TextEditInfo(toLength(r.fromLineNumber-1,0),toLength(r.toLineNumber,0),toLength(r.toLineNumber-r.fromLineNumber+1,0))));this.astWithTokens=this.parseDocumentFromTextBuffer(edits,this.astWithTokens,!1),this.initialAstWithoutTokens||this.didChangeEmitter.fire()}handleContentChanged(change){const edits=change.changes.map((c=>{const range=Range.lift(c.range);return new TextEditInfo(positionToLength(range.getStartPosition()),positionToLength(range.getEndPosition()),lengthOfString(c.text))})).reverse();this.astWithTokens=this.parseDocumentFromTextBuffer(edits,this.astWithTokens,!1),this.initialAstWithoutTokens&&(this.initialAstWithoutTokens=this.parseDocumentFromTextBuffer(edits,this.initialAstWithoutTokens,!1))}parseDocumentFromTextBuffer(edits,previousAst,immutable){const previousAstClone=previousAst,tokenizer=new TextBufferTokenizer(this.textModel,this.brackets);return parseDocument(tokenizer,edits,previousAstClone,immutable)}getBracketsInRange(range){const startOffset=toLength(range.startLineNumber-1,range.startColumn-1),endOffset=toLength(range.endLineNumber-1,range.endColumn-1),result=new Array,node=this.initialAstWithoutTokens||this.astWithTokens;return collectBrackets(node,lengthZero,node.length,startOffset,endOffset,result),result}getBracketPairsInRange(range,includeMinIndentation){const result=new Array,startLength=positionToLength(range.getStartPosition()),endLength=positionToLength(range.getEndPosition()),node=this.initialAstWithoutTokens||this.astWithTokens,context=new CollectBracketPairsContext(result,includeMinIndentation,this.textModel);return collectBracketPairs(node,lengthZero,node.length,startLength,endLength,context),result}}function collectBrackets(node,nodeOffsetStart,nodeOffsetEnd,startOffset,endOffset,result,level=0){if(4===node.kind)for(const child of node.children)nodeOffsetEnd=lengthAdd(nodeOffsetStart,child.length),lengthLessThanEqual(nodeOffsetStart,endOffset)&&lengthGreaterThanEqual(nodeOffsetEnd,startOffset)&&collectBrackets(child,nodeOffsetStart,nodeOffsetEnd,startOffset,endOffset,result,level),nodeOffsetStart=nodeOffsetEnd;else if(2===node.kind){level++;{const child=node.openingBracket;if(nodeOffsetEnd=lengthAdd(nodeOffsetStart,child.length),lengthLessThanEqual(nodeOffsetStart,endOffset)&&lengthGreaterThanEqual(nodeOffsetEnd,startOffset)){const range=lengthsToRange(nodeOffsetStart,nodeOffsetEnd);result.push(new BracketInfo(range,level-1,!node.closingBracket))}nodeOffsetStart=nodeOffsetEnd}if(node.child){const child=node.child;nodeOffsetEnd=lengthAdd(nodeOffsetStart,child.length),lengthLessThanEqual(nodeOffsetStart,endOffset)&&lengthGreaterThanEqual(nodeOffsetEnd,startOffset)&&collectBrackets(child,nodeOffsetStart,nodeOffsetEnd,startOffset,endOffset,result,level),nodeOffsetStart=nodeOffsetEnd}if(node.closingBracket){const child=node.closingBracket;if(nodeOffsetEnd=lengthAdd(nodeOffsetStart,child.length),lengthLessThanEqual(nodeOffsetStart,endOffset)&&lengthGreaterThanEqual(nodeOffsetEnd,startOffset)){const range=lengthsToRange(nodeOffsetStart,nodeOffsetEnd);result.push(new BracketInfo(range,level-1,!1))}nodeOffsetStart=nodeOffsetEnd}}else if(3===node.kind){const range=lengthsToRange(nodeOffsetStart,nodeOffsetEnd);result.push(new BracketInfo(range,level-1,!0))}else if(1===node.kind){const range=lengthsToRange(nodeOffsetStart,nodeOffsetEnd);result.push(new BracketInfo(range,level-1,!1))}}class CollectBracketPairsContext{constructor(result,includeMinIndentation,textModel){this.result=result,this.includeMinIndentation=includeMinIndentation,this.textModel=textModel}}function collectBracketPairs(node,nodeOffset,nodeOffsetEnd,startOffset,endOffset,context,level=0){var _a;if(2===node.kind){const openingBracketEnd=lengthAdd(nodeOffset,node.openingBracket.length);let minIndentation=-1;context.includeMinIndentation&&(minIndentation=node.computeMinIndentation(nodeOffset,context.textModel)),context.result.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffset,nodeOffsetEnd),lengthsToRange(nodeOffset,openingBracketEnd),node.closingBracket?lengthsToRange(lengthAdd(openingBracketEnd,(null===(_a=node.child)||void 0===_a?void 0:_a.length)||lengthZero),nodeOffsetEnd):void 0,level,minIndentation)),level++}let curOffset=nodeOffset;for(const child of node.children){const childOffset=curOffset;curOffset=lengthAdd(curOffset,child.length),lengthLessThanEqual(childOffset,endOffset)&&lengthLessThanEqual(startOffset,curOffset)&&collectBracketPairs(child,childOffset,curOffset,startOffset,endOffset,context,level)}}